<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width,
               height=device-height,
               initial-scale=1.0,
               maximum-scale=1.0,
               user-scalable=no,
               viewport-fit=cover">
<title>Space Shooter</title>
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Space Shooter">
<link rel="apple-touch-icon" sizes="180x180" href="icon.png">
<link rel="icon" type="image/png" href="icon.png">
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100vh;
  background: black;
  overflow: hidden;
  touch-action: none;
  font-family: sans-serif;
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
}
canvas { display:block; margin:0 auto; touch-action: none; -webkit-tap-highlight-color: transparent; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
// ===== CANVAS & DPR & logical size =====
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// make pixel-art crisp
if ('imageSmoothingEnabled' in ctx) ctx.imageSmoothingEnabled = false;

let dpr = Math.min(window.devicePixelRatio || 1, 2);
let lw = 0, lh = 0; // logical width/height in CSS pixels

const isiOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

// Adaptive star count based on device class
function computeStarCount() {
  // lower for small screens & iOS to save CPU
  if (isiOS) return 140;
  const area = window.innerWidth * window.innerHeight;
  if (area < 360000) return 180;
  return 300;
}

let STAR_COUNT = computeStarCount();

function resize() {
  dpr = Math.min(window.devicePixelRatio || 1, 2);
  const ratio = 9/16;
  const w = window.innerWidth;
  const h = window.innerHeight;
  let width, height;
  if (w / h > ratio) {
    height = h;
    width = Math.round(h * ratio);
  } else {
    width = w;
    height = Math.round(w * ratio);
  }
  // CSS size (logical)
  canvas.style.width = width + "px";
  canvas.style.height = height + "px";
  lw = width;
  lh = height;
  // backing store (physical)
  canvas.width = Math.round(width * dpr);
  canvas.height = Math.round(height * dpr);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if ('imageSmoothingEnabled' in ctx) ctx.imageSmoothingEnabled = false;

  // recompute star count for this resolution
  STAR_COUNT = computeStarCount();
  initStars();
}
window.addEventListener("resize", resize);
resize();

// ===== STATES =====
const MENU = 0, SETTINGS = 1, GAME = 2, PAUSE = 3, GAME_OVER = 4, SHOP = 5;
let state = MENU;

// ===== ASSET LOADER HELPERS =====
function makeImage(src){
  const img = new Image();
  img.__loaded = false;
  img.src = src;
  img.onload = ()=> { img.__loaded = true; };
  img.onerror = ()=> { img.__loaded = false; console.warn('Image load failed:', src); };
  // try decode() to mark loaded as soon as ready (modern browsers)
  if (img.decode) {
    img.decode().then(()=>{ img.__loaded = true; }).catch(()=>{ /* ignore */ });
  }
  return img;
}

// ===== ASSETS =====
const playerImg = makeImage("player.png");
const enemyImg  = makeImage("enemy.png");
const skinImg1 = makeImage("skin1.png");
const skinImg2 = makeImage("skin2.png");
const skinImg3 = makeImage("skin3.png");
const skinImg4 = makeImage("skin4.png");
const skinImg6 = makeImage("skin6.png"); // ваш файл skin6.png

// ===== AUDIO =====
const musicList = [ new Audio("music1.mp3"), new Audio("music2.mp3"), new Audio("music3.mp3") ];
let musicIndex = 0;
let musicVolume = 0.3, sfxVolume = 0.4;
musicList.forEach(m => { m.loop = true; m.volume = musicVolume; });
const laserSound = new Audio("laser.wav");
const gameOverSound = new Audio("gameover.wav");
const recordSound = new Audio("record.wav");
function updateVolumes(){ musicList.forEach(m => m.volume = musicVolume); laserSound.volume = sfxVolume; gameOverSound.volume = sfxVolume; recordSound.volume = sfxVolume; }
updateVolumes();

// ===== STORAGE =====
let record = Number(localStorage.getItem("record")) || 0;
let coins  = Number(localStorage.getItem("coins"))  || 0;

// ===== PLAYER =====
const player = { x:0, y:0, w:48, h:48 };

// ===== GAME =====
let bullets = [];
let enemies = [];
let score = 0;
let lastShot = 0;

// ===== STARS =====
// Use a lighter-weight star structure and init on resize
let stars = [];
function initStars() {
  stars = Array.from({ length: STAR_COUNT }, () => ({
    x: Math.random(),
    y: Math.random(),
    s: Math.random()*2+1,
    v: (Math.random()*0.6 + 0.4) / 600 // velocity factor similar to original s/600 but precomputed
  }));
}
initStars();

// ===== SKINS =====
// Rare получает preview: skinImg6
const skins = [
  {id:0,name:"Rare",cost:100,color:null, preview:skinImg6},
  {id:1,name:"Epic",cost:200,color:"purple", preview:skinImg1},
  {id:2,name:"Mythical",cost:300,color:"red", preview:skinImg2},
  {id:3,name:"Legendary",cost:400,color:"yellow", preview:skinImg3},
  {id:4,name:"X",cost:1000,color:"white", preview:skinImg4}
];
let ownedSkins = JSON.parse(localStorage.getItem("ownedSkins")||"[0]");
let activeSkin = Number(localStorage.getItem("activeSkin")||0);

// ensure player sprite uses active skin at start (если превью уже загружено — применим)
(function initSkin() {
  const skin = skins.find(s => s.id === activeSkin);
  if (skin && skin.preview && skin.preview.__loaded) playerImg.src = skin.preview.src;
})();

// helper: current player image (fallback to base)
function getActivePlayerImage() {
  const skin = skins.find(s => s.id === activeSkin);
  if (skin && skin.preview && (skin.preview.__loaded || (skin.preview.complete && skin.preview.naturalWidth))) return skin.preview;
  return playerImg;
}

// ===== AUDIO UNLOCK =====
let audioUnlocked = false;
function unlockAudioAndMaybePlayMenu(){
  if (audioUnlocked) return;
  audioUnlocked = true;
  // prime audio
  [...musicList, laserSound, gameOverSound, recordSound].forEach(a=>{
    a.play().then(()=>a.pause()).catch(()=>{});
    a.currentTime = 0;
  });
  try {
    if (state === MENU) {
      musicList.forEach(m=>m.pause());
      musicList[musicIndex].currentTime = 0;
      musicList[musicIndex].play().catch(()=>{});
    }
  } catch(e){}
}

// ===== INPUT =====
// prevent Safari iOS from scrolling/pinch-zoom while touching canvas
canvas.addEventListener("touchstart", e => { try{ e.preventDefault(); } catch(e){} }, { passive:false });
canvas.addEventListener("touchmove", e => { try{ e.preventDefault(); } catch(e){} }, { passive:false });

// also support mouse/pointer for desktop testing without changing behavior
canvas.addEventListener("pointerdown", e => {
  if (e.pointerType === 'mouse') {
    // treat as touchstart for desktop
    const rect = canvas.getBoundingClientRect();
    touchX = e.clientX - rect.left;
    // unlock audio if needed
    unlockAudioAndMaybePlayMenu();
    // emulate the existing touch logic by dispatching a synthetic touchstart-like path
    // We'll reuse same handler logic by creating a fake event object with touches
    const fake = { touches:[{clientX:e.clientX, clientY:e.clientY}] };
    handleTouchStart(fake);
  }
}, { passive: true });

let touchX = null;
function getTouchPosFromTouches(touches){
  const rect = canvas.getBoundingClientRect();
  const x = touches[0].clientX - rect.left;
  const y = touches[0].clientY - rect.top;
  return { x, y };
}

function handleTouchStart(e) {
  const pos = getTouchPosFromTouches(e.touches);
  const x = pos.x, y = pos.y;
  touchX = x;

  // pause button (logical coords)
  if (state === GAME) {
    if (x > lw - 50 && y < 50) { state = PAUSE; try { musicList[musicIndex].pause(); } catch(e){}; return; }
  }

  if (state === MENU) {
    const btnH = lw * 0.08;
    const startCY = lh * 0.48;
    const settingsCY = lh * 0.56;
    const shopCY = lh * 0.64;
    if (y > startCY - btnH/2 && y < startCY + btnH/2) { startGame(); return; }
    if (y > settingsCY - btnH/2 && y < settingsCY + btnH/2) { state = SETTINGS; try { musicList[musicIndex].pause(); } catch(e){}; return; }
    if (y > shopCY - btnH/2 && y < shopCY + btnH/2) { state = SHOP; try { musicList[musicIndex].pause(); } catch(e){}; return; }
  }

  if (state === SETTINGS) {
    if (y > lh*0.35 && y < lh*0.42) musicVolume = Math.max(0, musicVolume - 0.1);
    else if (y > lh*0.42 && y < lh*0.49) musicVolume = Math.min(1, musicVolume + 0.1);
    else if (y > lh*0.49 && y < lh*0.56) sfxVolume = Math.max(0, sfxVolume - 0.1);
    else if (y > lh*0.56 && y < lh*0.63) sfxVolume = Math.min(1, sfxVolume + 0.1);
    else if (y > lh*0.63 && y < lh*0.7) { musicList.forEach(m => m.pause()); musicIndex = (musicIndex + 1) % musicList.length; try { musicList[musicIndex].play(); } catch(e){} }
    else if (y > lh*0.78) { state = MENU; try { musicList[musicIndex].play(); } catch(e){} }
    updateVolumes();
    return;
  }

  if (state === SHOP) {
    skins.forEach((s,i) => {
      const cardY = lh*0.28 + i*100;
      if (y > cardY - 50 && y < cardY + 50) {
        if (!ownedSkins.includes(s.id)) {
          if (coins >= s.cost) {
            coins -= s.cost;
            ownedSkins.push(s.id);
            localStorage.setItem("coins", coins);
            localStorage.setItem("ownedSkins", JSON.stringify(ownedSkins));
          }
        }
        if (ownedSkins.includes(s.id)) {
          activeSkin = s.id;
          localStorage.setItem("activeSkin", activeSkin);
          // immediately apply sprite so player in-game shows selected skin
          if (s.preview && s.preview.src) playerImg.src = s.preview.src;
        }
      }
    });
    if (y > lh*0.92) { state = MENU; try { musicList[musicIndex].play(); } catch(e){} }
    return;
  }

  if (state === PAUSE) { state = GAME; try { musicList[musicIndex].play(); } catch(e){}; return; }
  if (state === GAME_OVER) { state = MENU; try { musicList[musicIndex].play(); } catch(e){}; return; }
}

canvas.addEventListener("touchstart", (e) => { unlockAudioAndMaybePlayMenu(); handleTouchStart(e); }, { passive:false });
canvas.addEventListener("touchmove", e => {
  const rect = canvas.getBoundingClientRect();
  touchX = e.touches[0].clientX - rect.left;
}, { passive:true });
canvas.addEventListener("touchend", ()=>touchX=null, { passive:true });

// ===== START GAME =====
function startGame(){
  player.x = lw/2 - player.w/2;
  player.y = lh - player.h - 20;
  bullets = []; enemies = []; score = 0; lastShot = 0;
  state = GAME;
  try { musicList.forEach(m=>m.pause()); musicList[musicIndex].currentTime = 0; musicList[musicIndex].play(); } catch(e){}
}

// ===== DRAW HELPERS =====
function drawStars(){
  // iterate local ref for speed
  for (let i=0, n=stars.length; i<n; i++) {
    const s = stars[i];
    s.y += s.v;
    if (s.y > 1) s.y = 0;
    ctx.fillRect(s.x*lw, s.y*lh, s.s, s.s);
  }
}
function center(text, y, size=24){
  ctx.fillStyle = "white";
  ctx.font = `${size}px sans-serif`;
  ctx.textAlign = "center";
  ctx.fillText(text, lw/2, y);
}

// ===== FIRE (one then second) =====
function fireBurst(){
  bullets.push({ x: player.x + player.w/2 - 2, y: player.y });
  try { laserSound.currentTime = 0; laserSound.play(); } catch(e){}
  setTimeout(()=>{ bullets.push({ x: player.x + player.w/2 - 2, y: player.y }); try { laserSound.currentTime = 0; laserSound.play(); } catch(e){} }, 120);
}

// ===== UPDATE LOOP =====
// use logical size (lw,lh) for drawing to avoid scaling artifacts
function update(){
  ctx.clearRect(0,0,lw,lh);
  ctx.fillStyle = "white";
  drawStars();

  if (state === MENU){
    center("SPACE SHOOTER", lh*0.32, Math.round(lw*0.04) || 40);
    center("START", lh*0.48);
    center("SETTINGS", lh*0.56);
    center("SHOP", lh*0.64);
    center("COINS: " + coins, lh*0.72, 18);
    return;
  }

  if (state === SETTINGS){
    center("SETTINGS", lh*0.25, 36);
    center("Music -", lh*0.38);
    center("Music +", lh*0.45);
    center("SFX -", lh*0.52);
    center("SFX +", lh*0.59);
    center("Change Music", lh*0.66);
    center("BACK", lh*0.82);
    return;
  }

  if (state === SHOP){
    center("SHOP", lh*0.12, 36);
    ctx.fillStyle = "white"; ctx.font = "16px sans-serif"; ctx.textAlign = "center";
    ctx.fillText("COINS: " + coins, lw/2, lh*0.16);

    // Cache repeated values in local vars for performance
    const lw06 = lw*0.06, lw88 = lw*0.88, imgXbase = lw*0.08, maxImgW = Math.min(120, lw*0.26), maxImgH = Math.min(80, 90);
    for (let i=0; i<skins.length; i++){
      const s = skins[i];
      const y = lh*0.28 + i*100;
      ctx.fillStyle = "rgba(255,255,255,0.03)";
      ctx.fillRect(lw06, y-50, lw88, 100);
      const imgX = imgXbase; const imgY = y-40; const imgW = maxImgW; const imgH = maxImgH;

      // reliable check: __loaded OR complete+naturalWidth
      const isReady = s.preview && (s.preview.__loaded || (s.preview.complete && s.preview.naturalWidth && s.preview.naturalWidth > 0));
      if (isReady) {
        try {
          ctx.drawImage(s.preview, imgX, imgY, imgW, imgH);
        } catch(e) {
          ctx.fillStyle = s.color || "#aaa";
          ctx.fillRect(imgX,imgY,imgW,imgH);
        }
      } else {
        // fallback: цветной прямоугольник если превью еще не загружено
        ctx.fillStyle = s.color || "#777";
        ctx.fillRect(imgX,imgY,imgW,imgH);
      }

      ctx.fillStyle = "white"; ctx.font = "18px sans-serif"; ctx.textAlign = "left";
      const labelX = imgX + imgW + 18;
      ctx.fillText(s.name, labelX, y - 6);
      ctx.font = "14px sans-serif"; const priceText = ownedSkins.includes(s.id) ? "OWNED" : s.cost + " coins";
      ctx.fillText(priceText, labelX, y + 18);
      ctx.font = "12px sans-serif"; ctx.fillStyle = s.color || "#aaa";
      ctx.fillText(s.id === activeSkin ? "SELECTED" : (ownedSkins.includes(s.id) ? "OWNED" : "BUY"), labelX + 160, y - 6);
      if (activeSkin === s.id) { ctx.strokeStyle = "#00ff88"; ctx.lineWidth = 2; ctx.strokeRect(lw06 + 2, y-50 + 2, lw88 - 4, 100 - 4); }
    }

    ctx.fillStyle = "white"; ctx.font = "16px sans-serif"; ctx.textAlign = "center";
    ctx.fillText("BACK", lw/2, lh*0.92);
    return;
  }

  if (state === PAUSE){
    center("PAUSED", lh*0.45, 40); center("TAP TO RESUME", lh*0.55, 18); return;
  }

  if (state === GAME){
    if (touchX !== null) player.x += (touchX - player.x - player.w/2) * 0.15;
    player.x = Math.max(0, Math.min(lw - player.w, player.x));

    if (Date.now() - lastShot > 650) { fireBurst(); lastShot = Date.now(); }

    // move bullets
    for (let i=0;i<bullets.length;i++) bullets[i].y -= 8;
    bullets = bullets.filter(b => b.y > -20);

    // spawn enemies
    if (Math.random() < 0.02) enemies.push({ x: Math.random() * (lw - 48), y: -50 });
    for (let i=0;i<enemies.length;i++) enemies[i].y += 3;

    // collisions (iterate backwards is slightly faster here in JS engines for splice)
    for (let i = enemies.length - 1; i >= 0; i--){
      const e = enemies[i];
      if (e.y > lh) { endGame(); return; }
      if (player.x < e.x + 48 && player.x + player.w > e.x && player.y < e.y + 48 && player.y + player.h > e.y) { endGame(); return; }
      for (let j = bullets.length - 1; j >= 0; j--){
        const b = bullets[j];
        if (b.x > e.x && b.x < e.x + 48 && b.y > e.y && b.y < e.y + 48) {
          enemies.splice(i,1); bullets.splice(j,1); score++; coins++; localStorage.setItem("coins", coins); break;
        }
      }
    }

    const playerSprite = getActivePlayerImage();
    try { ctx.drawImage(playerSprite, player.x, player.y, player.w, player.h); } catch(e){ ctx.fillStyle = "white"; ctx.fillRect(player.x, player.y, player.w, player.h); }

    ctx.fillStyle = "white";
    for (let i=0;i<bullets.length;i++){ const b=bullets[i]; ctx.fillRect(b.x, b.y, 4, 10); }
    for (let i=0;i<enemies.length;i++){
      const e = enemies[i];
      try { ctx.drawImage(enemyImg, e.x, e.y, 48, 48); } catch(e){ ctx.fillStyle = "red"; ctx.fillRect(e.x, e.y, 48, 48); }
    }

    ctx.font = "16px sans-serif"; ctx.textAlign = "left"; ctx.fillStyle = "white";
    ctx.fillText("Score: " + score, 12, 22);
    ctx.fillText("Record: " + record, 12, 40);
    ctx.fillText("Coins: " + coins, 12, 58);
    ctx.textAlign = "right"; ctx.fillText("⏸", lw - 16, 30);
    return;
  }

  if (state === GAME_OVER){
    center("GAME OVER", lh*0.45, 40); center("TAP TO MENU", lh*0.55, 18); return;
  }
}

// ===== endGame =====
function endGame(){
  try { musicList[musicIndex].pause(); } catch(e){}
  if (score > record) { record = score; localStorage.setItem("record", record); try { recordSound.currentTime = 0; recordSound.play(); } catch(e){} }
  else { try { gameOverSound.currentTime = 0; gameOverSound.play(); } catch(e){} }
  state = GAME_OVER;
}

// ===== Visibility handling (reduce CPU when hidden) =====
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    try { musicList.forEach(m => m.pause()); } catch(e){}
  } else {
    if (state === MENU && audioUnlocked) {
      try { musicList.forEach(m=>m.pause()); musicList[musicIndex].currentTime = 0; musicList[musicIndex].play().catch(()=>{}); } catch(e){}
    }
  }
});

// ===== Adaptive FPS controller =====
let lastFrameTime = 0;
let frameTimes = [];
let TARGET_FPS = 60; // start at 60 for consistency on mobile
let FRAME_TIME = 1000 / TARGET_FPS;

function adaptFPS(elapsed){
  frameTimes.push(elapsed);
  if (frameTimes.length > 30) frameTimes.shift();
  const avg = frameTimes.reduce((a,b)=>a+b,0)/frameTimes.length;
  // adapt thresholds conservatively to avoid changing gameplay noticeably
  if (avg > 22 && TARGET_FPS > 45) { TARGET_FPS = 45; FRAME_TIME = 1000 / TARGET_FPS; }
  else if (avg > 33 && TARGET_FPS > 30) { TARGET_FPS = 30; FRAME_TIME = 1000 / TARGET_FPS; }
  else if (avg < 14 && TARGET_FPS < 60) { TARGET_FPS = 60; FRAME_TIME = 1000 / TARGET_FPS; }
}

// ===== main loop =====
(function loop(time){
  if (document.hidden) { requestAnimationFrame(loop); return; }
  if (!lastFrameTime) lastFrameTime = time;
  const elapsed = time - lastFrameTime;
  if (elapsed >= FRAME_TIME) {
    update();
    adaptFPS(elapsed);
    lastFrameTime = time - (elapsed % FRAME_TIME);
  }
  requestAnimationFrame(loop);
})();

// ensure menu music plays (keeps original logic)
(function ensureMenuMusic(){
  if (state === MENU && audioUnlocked) {
    try { if (musicList[musicIndex].paused) { musicList.forEach(m=>m.pause()); musicList[musicIndex].currentTime = 0; musicList[musicIndex].play().catch(()=>{}); } } catch(e){}
  }
  requestAnimationFrame(ensureMenuMusic);
})();

// debug
window.__gameDebug = {
  coins: ()=>coins,
  addCoins: (n=1)=>{ coins+=n; localStorage.setItem("coins",coins); },
  setState: s=>{ state=s; },
  setTargetFPS: f=>{ TARGET_FPS = f; FRAME_TIME = 1000/TARGET_FPS; frameTimes = []; }
};
</script>
</body>
</html>

