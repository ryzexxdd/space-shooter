<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Space Shooter</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Space Shooter">
<link rel="icon" type="image/png" href="icon.png">

<style>
  html,body{
    margin:0; padding:0;
    width:100%; height:100vh;
    background:black;
    -webkit-user-select:none; user-select:none;
    -webkit-tap-highlight-color: rgba(0,0,0,0);
    touch-action:none;
    font-family: sans-serif;
  }
  canvas{ display:block; margin:0 auto; background:transparent; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
/* ========== Space Shooter — fixed & optimized for iPhone ==========
   Changes:
   - Rare no bright blue placeholder (neutral dark box)
   - Shooting: one bullet then immediately the second (sequence)
   - iPhone optimizations: DPR scaling, fewer stars on small screens,
     passive touch listeners, small performance tweaks.
   - All coordinates use CSS pixels (ctx scaled by DPR).
==================================================================== */

// Canvas + DPR handling
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function setSize(){
  const ratio = 9/16;
  const winW = window.innerWidth;
  const winH = window.innerHeight;
  let cssW, cssH;
  if (winW / winH > ratio){
    cssH = Math.floor(winH);
    cssW = Math.floor(cssH * ratio);
  } else {
    cssW = Math.floor(winW);
    cssH = Math.floor(cssW / ratio);
  }
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  canvas.width = Math.max(1, Math.floor(cssW * DPR));
  canvas.height = Math.max(1, Math.floor(cssH * DPR));
  // make drawing coordinates use CSS pixels
  ctx.setTransform(DPR,0,0,DPR,0,0);
  canvas._cssW = cssW;
  canvas._cssH = cssH;
  createStars();
}
window.addEventListener('resize', setSize, {passive:true});
setSize();

// quick helpers for CSS coords
function W(){ return canvas._cssW; }
function H(){ return canvas._cssH; }

// ===== states =====
const MENU=0, SETTINGS=1, GAME=2, PAUSE=3, GAME_OVER=4, SHOP=5;
let state = MENU;

// ===== assets =====
const playerImg = new Image(); playerImg.src = "player.png";
const enemyImg  = new Image(); enemyImg.src  = "enemy.png";

const skinImg1 = new Image(); skinImg1.src = "skin1.png";
const skinImg2 = new Image(); skinImg2.src = "skin2.png";
const skinImg3 = new Image(); skinImg3.src = "skin3.png";
const skinImg4 = new Image(); skinImg4.src = "skin4.png";

// ===== audio =====
const musicList = [ new Audio("music1.mp3"), new Audio("music2.mp3"), new Audio("music3.mp3") ];
let musicIndex = 0;
let musicVolume = 0.35, sfxVolume = 0.45;
musicList.forEach(m => { m.loop = true; m.volume = musicVolume; });

const laserSound = new Audio("laser.wav");
const gameOverSound = new Audio("gameover.wav");
const recordSound = new Audio("record.wav");
function updateVolumes(){ musicList.forEach(m=>m.volume=musicVolume); laserSound.volume=sfxVolume; gameOverSound.volume=sfxVolume; recordSound.volume=sfxVolume; }
updateVolumes();

// ===== storage =====
let record = Number(localStorage.getItem('record')) || 0;
let coins = Number(localStorage.getItem('coins')) || 0;

// ===== player & game =====
const player = { x:0, y:0, w:48, h:48 };
let bullets = [];
let enemies = [];
let score = 0;
let lastShot = 0;

// ===== stars (adaptive count) =====
let stars = [];
function createStars(){
  const cssW = W();
  const count = cssW < 420 ? 120 : 300;
  stars = Array.from({length:count}, ()=>({ x: Math.random(), y: Math.random(), s: Math.random()*1.8 + 0.8 }));
}
createStars();

// ===== skins =====
// id0 = Rare (neutral placeholder), 1..4 -> previews
const skins = [
  {id:0, name:"Rare", cost:100, color:"#333", preview:null},
  {id:1, name:"Epic", cost:200, color:"purple", preview:skinImg1},
  {id:2, name:"Mythical", cost:300, color:"red", preview:skinImg2},
  {id:3, name:"Legendary", cost:400, color:"orange", preview:skinImg3},
  {id:4, name:"X", cost:1000, color:"white", preview:skinImg4}
];
let ownedSkins = JSON.parse(localStorage.getItem('ownedSkins')||'[0]');
let activeSkin = Number(localStorage.getItem('activeSkin')||0);

// ===== audio unlock for iOS =====
let audioUnlocked = false;
function unlockAudio(){
  if (audioUnlocked) return;
  audioUnlocked = true;
  [...musicList, laserSound, gameOverSound, recordSound].forEach(a=>{
    a.play().then(()=>a.pause()).catch(()=>{});
    a.currentTime = 0;
  });
  try { musicList[musicIndex].play().catch(()=>{}); } catch(e){}
}

// ===== input (touch) =====
let touchX = null;

canvas.addEventListener('touchstart', e => {
  unlockAudio();
  const r = canvas.getBoundingClientRect();
  const x = e.touches[0].clientX - r.left;
  const y = e.touches[0].clientY - r.top;
  touchX = x;

  // pause icon area
  if (state === GAME && x > W() - 48 && y < 48){ state = PAUSE; try { musicList[musicIndex].pause(); } catch(e){}; return; }

  if (state === MENU){
    const btnH = H()*0.08;
    const startCY = H()*0.48, settingsCY = H()*0.56, shopCY = H()*0.64;
    if (y > startCY-btnH/2 && y < startCY+btnH/2){ startGame(); return; }
    if (y > settingsCY-btnH/2 && y < settingsCY+btnH/2){ state = SETTINGS; try{ musicList[musicIndex].pause(); }catch{}; return; }
    if (y > shopCY-btnH/2 && y < shopCY+btnH/2){ state = SHOP; try{ musicList[musicIndex].pause(); }catch{}; return; }
  }

  if (state === SETTINGS){
    if (y > H()*0.78){ state = MENU; try{ musicList[musicIndex].play(); }catch{} }
    else {
      if (y > H()*0.35 && y < H()*0.42) musicVolume = Math.max(0, musicVolume - 0.1);
      else if (y > H()*0.42 && y < H()*0.49) musicVolume = Math.min(1, musicVolume + 0.1);
      else if (y > H()*0.49 && y < H()*0.56) sfxVolume = Math.max(0, sfxVolume - 0.1);
      else if (y > H()*0.56 && y < H()*0.63) sfxVolume = Math.min(1, sfxVolume + 0.1);
      else if (y > H()*0.63 && y < H()*0.7){
        musicList.forEach(m=>m.pause());
        musicIndex = (musicIndex+1) % musicList.length;
        try{ musicList[musicIndex].play(); } catch(e){}
      }
      updateVolumes();
    }
    return;
  }

  if (state === SHOP){
    skins.forEach((s,i)=>{
      const cardY = H()*0.28 + i*100;
      if (y > cardY-50 && y < cardY+50){
        if (!ownedSkins.includes(s.id)){
          if (coins >= s.cost){ coins -= s.cost; ownedSkins.push(s.id); localStorage.setItem('coins', coins); localStorage.setItem('ownedSkins', JSON.stringify(ownedSkins)); }
        } else { activeSkin = s.id; localStorage.setItem('activeSkin', activeSkin); }
      }
    });
    if (y > H()*0.92){ state = MENU; try{ musicList[musicIndex].play(); }catch{} }
    return;
  }

  if (state === PAUSE){ state = GAME; try{ musicList[musicIndex].play(); }catch{}; return; }
  if (state === GAME_OVER){ state = MENU; try{ musicList[musicIndex].play(); }catch{}; return; }

}, {passive:true});

canvas.addEventListener('touchmove', e => { const r = canvas.getBoundingClientRect(); touchX = e.touches[0].clientX - r.left; }, {passive:true});
canvas.addEventListener('touchend', ()=> touchX = null, {passive:true});

// ===== startGame =====
function startGame(){
  player.x = W()/2 - player.w/2;
  player.y = H() - player.h - 20;
  bullets = []; enemies = []; score = 0; lastShot = 0;
  state = GAME;
  try { musicList.forEach(m=>m.pause()); musicList[musicIndex].currentTime = 0; musicList[musicIndex].play().catch(()=>{}); } catch(e){}
}

// ===== draw helpers =====
function drawStars(){
  ctx.fillStyle = 'white';
  for (let s of stars){
    s.y += s.s / 700;
    if (s.y > 1) s.y = 0;
    ctx.fillRect(s.x * W(), s.y * H(), s.s, s.s);
  }
}
function center(text, y, size=24){
  ctx.fillStyle = 'white';
  ctx.font = size + 'px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(text, W()/2, y);
}

// ===== fire sequence (one bullet then immediately second) =====
function fireSequence(){
  const bx = player.x + player.w/2 - 2;
  bullets.push({ x: bx, y: player.y });
  try { laserSound.currentTime = 0; laserSound.play(); } catch(e){}
  setTimeout(()=>{ bullets.push({ x: bx, y: player.y }); try { laserSound.currentTime = 0; laserSound.play(); } catch(e){} }, 120);
}

// ===== game loop update =====
function update(){
  // clear using CSS size
  ctx.clearRect(0,0,W(),H());
  drawStars();

  if (state === MENU){
    center('SPACE SHOOTER', H()*0.32, 40);
    center('START', H()*0.48, 28);
    center('SETTINGS', H()*0.56, 28);
    center('SHOP', H()*0.64, 28);
    center('COINS: ' + coins, H()*0.72, 16);
    return;
  }

  if (state === SETTINGS){
    center('SETTINGS', H()*0.25, 34);
    center('Music -', H()*0.38, 20);
    center('Music +', H()*0.45, 20);
    center('SFX -', H()*0.52, 20);
    center('SFX +', H()*0.59, 20);
    center('Change Music', H()*0.66, 18);
    center('BACK', H()*0.82, 20);
    return;
  }

  if (state === SHOP){
    center('SHOP', H()*0.12, 36);
    ctx.fillStyle='white'; ctx.font='16px sans-serif'; ctx.textAlign='center';
    ctx.fillText('COINS: ' + coins, W()/2, H()*0.16);

    skins.forEach((s,i)=>{
      const y = H()*0.28 + i*100;
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect(W()*0.06, y-50, W()*0.88, 100);

      const imgX = W()*0.08, imgY = y-40;
      const imgW = Math.min(120, W()*0.26), imgH = Math.min(80, 90);

      if (s.preview && s.preview.complete && s.id !== 0){
        try { ctx.drawImage(s.preview, imgX, imgY, imgW, imgH); } catch(e){ ctx.fillStyle=s.color||'white'; ctx.fillRect(imgX,imgY,imgW,imgH); }
      } else {
        // neutral placeholder for Rare (no bright blue)
        ctx.fillStyle = s.id === 0 ? '#222' : (s.color || 'white');
        ctx.fillRect(imgX, imgY, imgW, imgH);
      }

      ctx.fillStyle='white'; ctx.font='18px sans-serif'; ctx.textAlign='left';
      const labelX = imgX + imgW + 18;
      ctx.fillText(s.name, labelX, y-6);
      ctx.font='14px sans-serif';
      const priceText = ownedSkins.includes(s.id) ? 'OWNED' : s.cost + ' coins';
      ctx.fillText(priceText, labelX, y+18);

      ctx.font='12px sans-serif'; ctx.fillStyle = s.color || 'white';
      ctx.fillText(activeSkin===s.id ? 'SELECTED' : (ownedSkins.includes(s.id) ? 'OWNED' : 'BUY'), labelX + 160, y-6);

      if (activeSkin === s.id){
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2;
        ctx.strokeRect(W()*0.06 + 2, y-50 + 2, W()*0.88 - 4, 100 - 4);
      }
    });

    ctx.fillStyle='white'; ctx.font='16px sans-serif'; ctx.textAlign='center';
    ctx.fillText('BACK', W()/2, H()*0.92);
    return;
  }

  if (state === PAUSE){
    center('PAUSED', H()*0.45, 36);
    center('TAP TO RESUME', H()*0.55, 18);
    return;
  }

  if (state === GAME){
    // move player toward touchX
    if (touchX !== null) player.x += (touchX - player.x - player.w/2) * 0.15;
    player.x = Math.max(0, Math.min(W() - player.w, player.x));

    // firing sequence every interval
    if (Date.now() - lastShot > 650){
      fireSequence();
      lastShot = Date.now();
    }

    // bullets move
    for (let b of bullets) b.y -= 8;
    bullets = bullets.filter(b => b.y > -20);

    // spawn enemies
    if (Math.random() < 0.02) enemies.push({ x: Math.random() * (W() - 48), y: -50 });
    for (let e of enemies) e.y += 3;

    // collisions & logic
    for (let i = enemies.length - 1; i >= 0; i--){
      const e = enemies[i];
      if (e.y > H()){ endGame(); return; }
      if (player.x < e.x + 48 && player.x + player.w > e.x && player.y < e.y + 48 && player.y + player.h > e.y){ endGame(); return; }
      for (let j = bullets.length - 1; j >= 0; j--){
        const b = bullets[j];
        if (b.x > e.x && b.x < e.x + 48 && b.y > e.y && b.y < e.y + 48){
          enemies.splice(i,1); bullets.splice(j,1); score++; coins++; localStorage.setItem('coins', coins); break;
        }
      }
    }

    // draw player
    try { ctx.drawImage(playerImg, player.x, player.y, player.w, player.h); } catch(e){ ctx.fillStyle='white'; ctx.fillRect(player.x, player.y, player.w, player.h); }

    // draw bullets & enemies
    ctx.fillStyle='white';
    for (let b of bullets) ctx.fillRect(b.x, b.y, 4, 10);
    for (let e of enemies){
      try { ctx.drawImage(enemyImg, e.x, e.y, 48, 48); } catch(e){ ctx.fillStyle='red'; ctx.fillRect(e.x,e.y,48,48); }
    }

    // HUD
    ctx.font='16px sans-serif'; ctx.textAlign='left'; ctx.fillStyle='white';
    ctx.fillText('Score: ' + score, 12, 22);
    ctx.fillText('Record: ' + record, 12, 40);
    ctx.fillText('Coins: ' + coins, 12, 58);

    // pause icon (visual)
    ctx.textAlign='right'; ctx.fillText('⏸', W() - 16, 30);

    return;
  }

  if (state === GAME_OVER){
    center('GAME OVER', H()*0.45, 36);
    center('TAP TO MENU', H()*0.55, 18);
    return;
  }
}

// ===== endGame =====
function endGame(){
  try { musicList[musicIndex].pause(); } catch(e){}
  if (score > record){
    record = score; localStorage.setItem('record', record);
    try { recordSound.currentTime = 0; recordSound.play(); } catch(e){}
  } else {
    try { gameOverSound.currentTime = 0; gameOverSound.play(); } catch(e){}
  }
  state = GAME_OVER;
}

// ===== loop =====
(function loop(){ update(); requestAnimationFrame(loop); })();

// ensure menu music plays when unlocked & in menu
(function ensureMenuMusic(){
  if (state === MENU && audioUnlocked){
    try {
      if (musicList[musicIndex].paused){
        musicList.forEach(m=>m.pause());
        musicList[musicIndex].currentTime = 0;
        musicList[musicIndex].play().catch(()=>{});
      }
    } catch(e){}
  }
  requestAnimationFrame(ensureMenuMusic);
})();

// debug helpers
window.__gameDebug = {
  coins: ()=>coins,
  addCoins: (n=1)=>{ coins+=n; localStorage.setItem('coins', coins); },
  setState: s=>{ state = s; }
};

</script>
</body>
</html>
