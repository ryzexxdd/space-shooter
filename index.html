<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">

<meta name="viewport"
      content="width=device-width,
               height=device-height,
               initial-scale=1.0,
               maximum-scale=1.0,
               user-scalable=no,
               viewport-fit=cover">

<title>Space Shooter</title>

<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Space Shooter">

<link rel="apple-touch-icon" sizes="180x180" href="icon.png">
<link rel="icon" type="image/png" href="icon.png">

<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100vh;
  background: black;
  overflow: hidden;
  touch-action: none;
  font-family: sans-serif;
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
}

canvas {
  display: block;
  margin: 0 auto;
  -webkit-transform: translateZ(0);
  transform: translateZ(0);
}
</style>
</head>

<body>
<canvas id="game"></canvas>

<script>
// ================================
// Space Shooter — финальный код
// изменения: Rare без синего цвета, стрельба "одна пулька -> сразу вторая",
// оптимизации под iPhone (DPR, уменьшение звёзд на малых экранах).
// ================================

// ===== CANVAS & DPR / resize =====
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

// helper to return CSS drawing width/height used for layout & input
function W() { return canvas._cssWidth || canvas.clientWidth || window.innerWidth; }
function H() { return canvas._cssHeight || canvas.clientHeight || window.innerHeight; }

function applySize() {
  // keep 9:16 ratio and center on screen
  const ratio = 9 / 16;
  const winW = window.innerWidth;
  const winH = window.innerHeight;
  let cssW, cssH;

  if (winW / winH > ratio) {
    cssH = Math.floor(winH);
    cssW = Math.floor(winH * ratio);
  } else {
    cssW = Math.floor(winW);
    cssH = Math.floor(winW / ratio);
  }

  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";

  // physical pixel size
  canvas.width = Math.max(1, Math.floor(cssW * DPR));
  canvas.height = Math.max(1, Math.floor(cssH * DPR));

  canvas._cssWidth = cssW;
  canvas._cssHeight = cssH;

  // scale drawing so all coordinates use css pixels
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  // recreate stars with density adapted to screen
  createStars();
}

window.addEventListener("resize", applySize, { passive: true });
applySize();

// ===== STATES =====
const MENU = 0;
const SETTINGS = 1;
const GAME = 2;
const PAUSE = 3;
const GAME_OVER = 4;
const SHOP = 5;
let state = MENU;

// ===== ASSETS =====
const playerImg = new Image(); playerImg.src = "player.png";
const enemyImg  = new Image(); enemyImg.src  = "enemy.png";

// skin preview images (user should add these files to same folder)
const skinImg1 = new Image(); skinImg1.src = "skin1.png"; // Epic
const skinImg2 = new Image(); skinImg2.src = "skin2.png"; // Mythical
const skinImg3 = new Image(); skinImg3.src = "skin3.png"; // Legendary
const skinImg4 = new Image(); skinImg4.src = "skin4.png"; // X

// ===== AUDIO =====
const musicList = [
  new Audio("music1.mp3"),
  new Audio("music2.mp3"),
  new Audio("music3.mp3")
];
let musicIndex = 0;
let musicVolume = 0.35;
let sfxVolume = 0.5;

musicList.forEach(m => { m.loop = true; m.volume = musicVolume; });

const laserSound   = new Audio("laser.wav");
const gameOverSound= new Audio("gameover.wav");
const recordSound  = new Audio("record.wav");

function updateVolumes() {
  musicList.forEach(m => m.volume = musicVolume);
  laserSound.volume = sfxVolume;
  gameOverSound.volume = sfxVolume;
  recordSound.volume = sfxVolume;
}
updateVolumes();

// ===== STORAGE =====
let record = Number(localStorage.getItem("record")) || 0;
let coins  = Number(localStorage.getItem("coins"))  || 0;

// ===== PLAYER =====
const player = { x:0, y:0, w:48, h:48 };

// ===== GAME =====
let bullets = [];
let enemies = [];
let score = 0;
let lastShot = 0;

// ===== STARS (adaptive) =====
let stars = [];
function createStars() {
  const cssW = W(), cssH = H();
  const base = cssW < 420 ? 140 : 260; // fewer stars on small screens
  stars = Array.from({ length: base }, () => ({
    x: Math.random(),
    y: Math.random(),
    s: Math.random() * 2 + 0.8
  }));
}
createStars();

// ===== SKINS (Rare WITHOUT blue fill) =====
// id 0 = base / Rare (no bright blue placeholder)
const skins = [
  {id:0,name:"Rare",cost:100,color:"#bbbbbb", preview:null},
  {id:1,name:"Epic",cost:200,color:"purple", preview:skinImg1},
  {id:2,name:"Mythical",cost:300,color:"red", preview:skinImg2},
  {id:3,name:"Legendary",cost:400,color:"orange", preview:skinImg3},
  {id:4,name:"X",cost:1000,color:"white", preview:skinImg4}
];
let ownedSkins = JSON.parse(localStorage.getItem("ownedSkins")||"[0]"); // default own skin 0
let activeSkin = Number(localStorage.getItem("activeSkin")||0);

// ===== AUDIO UNLOCK (для iOS/мобильных) =====
let audioUnlocked = false;
function unlockAudioAndMaybePlayMenu() {
  if (audioUnlocked) return;
  audioUnlocked = true;
  [...musicList, laserSound, gameOverSound, recordSound].forEach(a=>{
    a.play().then(()=>a.pause()).catch(()=>{});
    a.currentTime = 0;
  });
  // try start menu music if in menu
  try {
    if (state === MENU) {
      musicList.forEach(m=>m.pause());
      musicList[musicIndex].currentTime = 0;
      musicList[musicIndex].play().catch(()=>{});
    }
  } catch(e){}
}

// ===== INPUT =====
let touchX = null;

canvas.addEventListener("touchstart", e => {
  unlockAudioAndMaybePlayMenu();
  const r = canvas.getBoundingClientRect();
  const x = e.touches[0].clientX - r.left;
  const y = e.touches[0].clientY - r.top;
  touchX = x;

  // handle touch zones depending on state
  // small pause button area (top-right)
  if (state === GAME) {
    if (x > W() - 48 && y < 48) {
      state = PAUSE;
      try { musicList[musicIndex].pause(); } catch(e){}
      return;
    }
  }

  if (state === MENU) {
    const btnH = H() * 0.08;
    const startCY = H() * 0.48;
    const settingsCY = H() * 0.56;
    const shopCY = H() * 0.64;

    if (y > startCY - btnH/2 && y < startCY + btnH/2) {
      startGame();
      return;
    } else if (y > settingsCY - btnH/2 && y < settingsCY + btnH/2) {
      state = SETTINGS;
      try { musicList[musicIndex].pause(); } catch(e){}
      return;
    } else if (y > shopCY - btnH/2 && y < shopCY + btnH/2) {
      state = SHOP;
      try { musicList[musicIndex].pause(); } catch(e){}
      return;
    }
  }

  if (state === SETTINGS) {
    if (y > H()*0.35 && y < H()*0.42) musicVolume = Math.max(0, musicVolume - 0.1);
    else if (y > H()*0.42 && y < H()*0.49) musicVolume = Math.min(1, musicVolume + 0.1);
    else if (y > H()*0.49 && y < H()*0.56) sfxVolume = Math.max(0, sfxVolume - 0.1);
    else if (y > H()*0.56 && y < H()*0.63) sfxVolume = Math.min(1, sfxVolume + 0.1);
    else if (y > H()*0.63 && y < H()*0.7) {
      musicList.forEach(m=>m.pause());
      musicIndex = (musicIndex+1) % musicList.length;
      try { musicList[musicIndex].play(); } catch(e){}
    }
    else if (y > H()*0.78) {
      state = MENU;
      try { musicList[musicIndex].play(); } catch(e){}
    }
    updateVolumes();
    return;
  }

  if (state === SHOP) {
    skins.forEach((s,i)=>{
      const cardY = H()*0.28 + i*100;
      if (y > cardY - 50 && y < cardY + 50) {
        if (!ownedSkins.includes(s.id)) {
          if (coins >= s.cost) {
            coins -= s.cost;
            ownedSkins.push(s.id);
            localStorage.setItem("coins", coins);
            localStorage.setItem("ownedSkins", JSON.stringify(ownedSkins));
          }
        } else {
          activeSkin = s.id;
          localStorage.setItem("activeSkin", activeSkin);
        }
      }
    });
    if (y > H()*0.92) {
      state = MENU;
      try { musicList[musicIndex].play(); } catch(e){}
    }
    return;
  }

  if (state === PAUSE) {
    state = GAME;
    try { musicList[musicIndex].play(); } catch(e){}
    return;
  }

  if (state === GAME_OVER) {
    state = MENU;
    try { musicList[musicIndex].play(); } catch(e){}
    return;
  }
}, { passive: true });

canvas.addEventListener("touchmove", e => {
  const r = canvas.getBoundingClientRect();
  touchX = e.touches[0].clientX - r.left;
}, { passive: true });

canvas.addEventListener("touchend", ()=>{ touchX = null; }, { passive: true });

// ===== START GAME =====
function startGame() {
  player.x = W()/2 - player.w/2;
  player.y = H() - player.h - 20;
  bullets = [];
  enemies = [];
  score = 0;
  lastShot = 0;
  state = GAME;

  musicList.forEach(m => m.pause());
  musicList[musicIndex].currentTime = 0;
  musicList[musicIndex].play().catch(()=>{});
}

// ===== DRAW HELPERS =====
function drawStars() {
  ctx.fillStyle = "white";
  for (let s of stars) {
    s.y += s.s / 700; // slower background for mobile
    if (s.y > 1) s.y = 0;
    ctx.fillRect(s.x * W(), s.y * H(), s.s, s.s);
  }
}

function center(t, y, s = 24) {
  ctx.fillStyle = "white";
  ctx.font = s + "px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(t, W() / 2, y);
}

// ===== FIRE: одна пуля — сразу вторая (sequence) =====
// This function captures the player's current x and fires one bullet,
// then after a short delay fires the second from the same point.
function fireSequence() {
  const px = player.x + player.w / 2 - 2;
  bullets.push({ x: px, y: player.y });
  try { laserSound.currentTime = 0; laserSound.play(); } catch(e){}
  setTimeout(() => {
    bullets.push({ x: px, y: player.y });
    try { laserSound.currentTime = 0; laserSound.play(); } catch(e){}
  }, 120); // second follows after 120ms
}

// ===== UPDATE (game loop) =====
function update() {
  // clear with black
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawStars();

  if (state === MENU) {
    center("SPACE SHOOTER", H() * 0.32, 40);
    center("START", H() * 0.48, 28);
    center("SETTINGS", H() * 0.56, 28);
    center("SHOP", H() * 0.64, 28);
    center("COINS: " + coins, H() * 0.72, 16);
    return;
  }

  if (state === SETTINGS) {
    center("SETTINGS", H() * 0.25, 34);
    center("Music -", H() * 0.38, 20);
    center("Music +", H() * 0.45, 20);
    center("SFX -", H() * 0.52, 20);
    center("SFX +", H() * 0.59, 20);
    center("Change Music", H() * 0.66, 18);
    center("BACK", H() * 0.82, 20);
    return;
  }

  if (state === SHOP) {
    center("SHOP", H() * 0.12, 36);
    ctx.fillStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("COINS: " + coins, W() / 2, H() * 0.16);

    skins.forEach((s, i) => {
      const y = H() * 0.28 + i * 100;
      // card background
      ctx.fillStyle = "rgba(255,255,255,0.03)";
      ctx.fillRect(W() * 0.06, y - 50, W() * 0.88, 100);

      // preview image area
      const imgX = W() * 0.08;
      const imgY = y - 40;
      const imgW = Math.min(120, W() * 0.26);
      const imgH = Math.min(80, 90);

      if (s.preview && s.preview.complete && s.id !== 0) {
        try {
          ctx.drawImage(s.preview, imgX, imgY, imgW, imgH);
        } catch (e) {
          ctx.fillStyle = s.color || "white";
          ctx.fillRect(imgX, imgY, imgW, imgH);
        }
      } else {
        // for Rare (id 0) we draw a neutral placeholder without bright blue
        ctx.fillStyle = (s.id === 0) ? "#222222" : (s.color || "white");
        ctx.fillRect(imgX, imgY, imgW, imgH);
      }

      // name + price on the right
      ctx.fillStyle = "white";
      ctx.font = "18px sans-serif";
      ctx.textAlign = "left";
      const labelX = imgX + imgW + 18;
      ctx.fillText(s.name, labelX, y - 6);
      ctx.font = "14px sans-serif";
      const priceText = ownedSkins.includes(s.id) ? "OWNED" : s.cost + " coins";
      ctx.fillText(priceText, labelX, y + 18);

      // small tag (BUY / OWNED / SELECTED)
      ctx.font = "12px sans-serif";
      ctx.fillStyle = s.color || "white";
      const tagX = labelX + 160;
      const tagText = (activeSkin === s.id) ? "SELECTED" : (ownedSkins.includes(s.id) ? "OWNED" : "BUY");
      ctx.fillText(tagText, tagX, y - 6);

      // selected outline
      if (activeSkin === s.id) {
        ctx.strokeStyle = "#00ff88";
        ctx.lineWidth = 2;
        ctx.strokeRect(W() * 0.06 + 2, y - 50 + 2, W() * 0.88 - 4, 100 - 4);
      }
    });

    ctx.fillStyle = "white";
    ctx.font = "16px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("BACK", W() / 2, H() * 0.92);
    return;
  }

  if (state === PAUSE) {
    center("PAUSED", H() * 0.45, 36);
    center("TAP TO RESUME", H() * 0.55, 18);
    return;
  }

  if (state === GAME) {
    // move player toward touchX
    if (touchX !== null) {
      player.x += (touchX - player.x - player.w / 2) * 0.15;
    }
    player.x = Math.max(0, Math.min(W() - player.w, player.x));

    // sequence fire implemented: one bullet then shortly the second
    if (Date.now() - lastShot > 650) {
      fireSequence();
      lastShot = Date.now();
    }

    // bullets movement
    bullets.forEach(b => b.y -= 8);
    bullets = bullets.filter(b => b.y > -20);

    // enemies spawn and move
    if (Math.random() < 0.02) enemies.push({ x: Math.random() * (W() - 48), y: -50 });
    enemies.forEach(e => e.y += 3);

    // collisions & logic
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];

      if (e.y > H()) {
        endGame();
        return;
      }

      if (player.x < e.x + 48 && player.x + player.w > e.x &&
          player.y < e.y + 48 && player.y + player.h > e.y) {
        endGame();
        return;
      }

      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (b.x > e.x && b.x < e.x + 48 && b.y > e.y && b.y < e.y + 48) {
          enemies.splice(i, 1);
          bullets.splice(j, 1);
          score++;
          coins++;
          localStorage.setItem("coins", coins);
          break;
        }
      }
    }

    // draw player (no border)
    try {
      ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
    } catch (e) {
      ctx.fillStyle = "white";
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }

    // draw bullets & enemies
    ctx.fillStyle = "white";
    bullets.forEach(b => ctx.fillRect(b.x, b.y, 4, 10));
    enemies.forEach(e => {
      try { ctx.drawImage(enemyImg, e.x, e.y, 48, 48); } catch (err) {
        ctx.fillStyle = "red";
        ctx.fillRect(e.x, e.y, 48, 48);
      }
    });

    // HUD
    ctx.font = "16px sans-serif"; ctx.textAlign = "left";
    ctx.fillStyle = "white";
    ctx.fillText("Score: " + score, 12, 22);
    ctx.fillText("Record: " + record, 12, 40);
    ctx.fillText("Coins: " + coins, 12, 58);

    // pause icon
    ctx.textAlign = "right";
    ctx.fillText("⏸", W() - 16, 30);

    return;
  }

  if (state === GAME_OVER) {
    center("GAME OVER", H() * 0.45, 36);
    center("TAP TO MENU", H() * 0.55, 18);
    return;
  }
}

// ===== endGame =====
function endGame() {
  try { musicList[musicIndex].pause(); } catch (e) {}
  if (score > record) {
    record = score;
    localStorage.setItem("record", record);
    try { recordSound.currentTime = 0; recordSound.play(); } catch (e) {}
  } else {
    try { gameOverSound.currentTime = 0; gameOverSound.play(); } catch (e) {}
  }
  state = GAME_OVER;
}

// ===== animation loop =====
(function loop(){
  update();
  requestAnimationFrame(loop);
})();

// ===== ensure menu music plays when unlocked and in menu =====
(function ensureMenuMusic(){
  if (state === MENU && audioUnlocked) {
    try {
      if (musicList[musicIndex].paused) {
        musicList.forEach(m=>m.pause());
        musicList[musicIndex].currentTime = 0;
        musicList[musicIndex].play().catch(()=>{});
      }
    } catch(e){}
  }
  requestAnimationFrame(ensureMenuMusic);
})();

// ===== debug helpers =====
window.__gameDebug = {
  coins: ()=>coins,
  addCoins: (n=1)=>{ coins+=n; localStorage.setItem("coins",coins); },
  setState: s => { state = s; }
};

</script>
</body>
</html>
